package Project_Euler_Solutions_in_Java._32_63;

import Project_Euler_Solutions_in_Java.Utils.Util;

import java.util.*;

/**
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
 * are all figurate (polygonal) numbers and are generated by the following formulae:
 *
 * Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
 * Square	 	P4,n=n^2	 	1, 4, 9, 16, 25, ...
 * Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
 * Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
 * Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
 * Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
 *
 * The set is cyclic, in that the last two digits of each number
 * is the first two digits of the next number (including the last number with the first).
 * Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),
 * is represented by a different number in the set.
 * This is the only set of 4-digit numbers with this property.
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
 * triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
 */
public class _061_CyclicalFigurateNumbers {
    HashMap<String, List<String>> triangles = new HashMap<>();
    HashMap<String, List<String>> squares = new HashMap<>();
    HashMap<String, List<String>> pentagones = new HashMap<>();
    HashMap<String, List<String>> hexagons = new HashMap<>();
    HashMap<String, List<String>> heptagons = new HashMap<>();
    HashMap<String, List<String>> octagons = new HashMap<>();
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        Util.println("Result = " + new _061_CyclicalFigurateNumbers().run());
        long end = System.currentTimeMillis();
        Util.println("Total time: " + (end - start) * 0.001 + " s");
    }

    public int run() {
        generateFigurate(calculateTriangle, triangles);
        generateFigurate(calculateSquare, squares);
        generateFigurate(calculatePentagon, pentagones);
        generateFigurate(calculateHexagon, hexagons);
        generateFigurate(calculateHeptagon, heptagons);
        generateFigurate(calculateOctagon, octagons);
//        for (int o : octagons)
//            for (int hp : heptagons)
//                for (int hx : hexagons)
//                    for(int p : pentagones)
//                        for(int s : squares)
//                            for(int t : triangles)
//                                if (isComboCyclical(Arrays.asList(t, s, p, hx, hp, o))) {
//                                    return t + s + p + hx + hp + o;
//                                }
        return 0;
    }
    private boolean isComboCyclical(List<Integer> al){
        String remainder = String.valueOf(al.get(0)).substring(2);
        HashMap<String, String> hm = new HashMap<>();
        for(int element : al){
            splitNumberDownTheMiddle(element, hm);
        }
        for(int i = 0; i <= al.size(); i ++){
            if(hm.containsKey(remainder)){
                String tmp = remainder;
                remainder = hm.get(remainder);
                hm.replace(tmp, null);
            } else{
                return false;
            }
        }
        return true;
    }
    private void splitNumberDownTheMiddle(int n, HashMap<String,String> hm){
        String number = String.valueOf(n);
        hm.put(number.substring(0,2), number.substring(2));
    }
    private void generateFigurate(Calculation calc, HashMap<String, List<String>> hs){
        int i;
        for(i = 1; calc.evaluate(i) < 1000; i++){}
        for(;calc.evaluate(i) < 10000; i++){
            int eval = calc.evaluate(i);
            String evalString = String.valueOf(eval);
            String key = evalString.substring(0,2);
            String value = evalString.substring(2);
            if(value.charAt(0) == '0')
                continue;
            if(hs.containsKey(key)){
                hs.get(key).add(value);
            } else {
                hs.put(key, Arrays.asList(value));
            }
        }
    }
    private Calculation calculateTriangle = (n ->  n * (n + 1) / 2);
    private Calculation calculateSquare = (n ->  n * n);
    private Calculation calculatePentagon = (n ->  n * (3 * n - 1) / 2);
    private Calculation calculateHexagon = (n ->  n * (2*n - 1));
    private Calculation calculateHeptagon = (n ->  n * (5*n - 3) / 2);
    private Calculation calculateOctagon = (n ->  n * (3 * n - 2));
    public interface Calculation {
        int evaluate(int param);
    }
}
